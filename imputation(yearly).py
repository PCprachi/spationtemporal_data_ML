# -*- coding: utf-8 -*-
"""imputation(yearly).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dGrqkeACYlBvbLx1kQdOWfqKLG4qgNxk
"""

!pip install numpy
!pip install pandas
!pip install tqdm
import re
import numpy as np
import pandas as pd

from google.colab import drive
drive.mount('/content/drive')

df=pd.read_csv("/content/drive/MyDrive/spatiotemporal_trn_data.csv")
df.head

# drop columns with all null values
df = df.dropna(axis=1, how='all')

def get_date_dict(date_str):
    pattern = re.compile(r"^(?P<yr>\d{4})-(?P<mon>\d{2})-(?P<day>\d{2})T(?P<hr>\d{2}):(?P<min>\d{2}):(?P<sec>\d{2})$")
    match = pattern.match(date_str)
    return match.groupdict() if match else None

df['DATE_DICT'] = df['DATE'].apply(get_date_dict)

df.loc[:, 'YEAR'] = df['DATE_DICT'].apply(lambda x: int(x['yr']) if x else None)
df.loc[:, 'MONTH'] = df['DATE_DICT'].apply(lambda x: int(x['mon']) if x else None)
df.loc[:, 'DAY'] = df['DATE_DICT'].apply(lambda x: int(x['day']) if x else None)
df.loc[:, 'HOUR'] = df['DATE_DICT'].apply(lambda x: int(x['hr']) if x else None)
df.loc[:, 'MINUTES'] = df['DATE_DICT'].apply(lambda x: int(x['min']) if x else None)
df.loc[:, 'SECONDS'] = df['DATE_DICT'].apply(lambda x: int(x['sec']) if x else None)

# Drop the intermediate column
df = df.drop(columns=['DATE_DICT'])

# Add targets to same df
df['TARGETS'] = pd.read_csv('/content/drive/MyDrive/spatiotemporal_trn_targets.csv', names=['index', 'TARGETS'])['TARGETS']

df.info()

df.head()

df = df.drop(["SOURCE", "REPORT_TYPE", "NAME", "REM", "DATE", 'LATITUDE', 'LONGITUDE', "HourlyPrecipitation", "HourlyPressureChange","HourlyWindGustSpeed","ShortDurationPrecipitationValue150"],axis=1)

df.head()

df.info()

def get_numeric(string):
    try:
        return float(string)
    except ValueError:
        if isinstance(string, str):
            reg = re.compile(r"(?P<num>-?\d+)(?P<dec>\.\d+)?")
            match = reg.match(string)
            if match:
                num = match.group('num')
                dec = match.group('dec')
                if dec:
                    return float(num + dec)
                else:
                    return float(num)
        return np.nan

df.HourlyAltimeterSetting.value_counts()

#str to float conversion
df['HourlyAltimeterSetting'] = df['HourlyAltimeterSetting'].apply(get_numeric)
df['HourlyDewPointTemperature'] = df['HourlyDewPointTemperature'].apply(get_numeric)
df['HourlyDryBulbTemperature'] = df['HourlyDryBulbTemperature'].apply(get_numeric)
df['HourlySeaLevelPressure'] = df['HourlySeaLevelPressure'].apply(get_numeric)
df['HourlyStationPressure'] = df['HourlyStationPressure'].apply(get_numeric)
df['HourlyWindSpeed'] = df['HourlyWindSpeed'].apply(get_numeric)
df['HourlyWindDirection'] = df['HourlyWindDirection'].apply(get_numeric)
df['TARGETS'] = df['TARGETS'].apply(get_numeric)

df.info()

df.HourlyPresentWeatherType.value_counts()

df = df[df['TARGETS'] < 20]

df.head()

df.info()

df.drop(['SECONDS'], axis = 1, inplace = True)

df.sort_values(['STATION', 'YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTES'], inplace = True)

df.reset_index(inplace = True, drop=True)

df.head()

!pip install tqdm
groups = []
start = 0
for idx in (range(1, len(df))):
    if df.STATION[idx-1] == df.STATION[idx]:
        continue
    else:
        end = idx-1
        groups.append((start, end))
        start = idx

groups.append((start, len(df)-1))

len(groups) == df.STATION.nunique()

groups

cols = ['HourlyAltimeterSetting', 'HourlyDewPointTemperature', 'HourlyDryBulbTemperature', 'HourlyPressureTendency',
       'HourlyRelativeHumidity', 'HourlySeaLevelPressure', 'HourlyStationPressure', 'HourlyWetBulbTemperature',
       'HourlyWindDirection', 'HourlyWindSpeed']

for start, end in (groups):
    temp = df[start:end+1]
    for col in cols:
        temp[col] = temp[col].interpolate()
    df[start:end+1] = temp

df.info()

import matplotlib.pyplot as plt
trend = df[['YEAR', 'TARGETS']].groupby('YEAR').mean()

# Set the figure size
plt.figure(figsize=(7, 5))  # Adjust the values as needed

# Change line style for negative values to '--' and color to 'blue'
plt.plot(trend.index, trend['TARGETS'], '-o', color='blue', linestyle='--')

plt.title('Yearly Trend of TARGETS')
plt.xlabel('Year')
plt.ylabel('Mean TARGETS')
plt.grid(True)
plt.show()

i = 1
plt.figure(figsize = (10, 10))
for col in cols:
    trend = df[['YEAR', col]].groupby('YEAR').mean()
    plt.figure(figsize = (5, 10))
    plt.subplot(10, 1, i)
    plt.plot(trend.index, trend[col], '-o')
    i += 1

i = 1
for col in cols:
    try:
        plt.figure(figsize=(5, 5))
        plt.subplot(5, 2, i)
        plt.title(col, fontdict={'fontsize': 12, 'fontweight': 'bold', 'color': 'blue'})
        plt.hist(df[col], color='green', edgecolor='black')  # Adjust color as needed
        plt.xlabel(col, fontdict={'fontsize': 10, 'fontweight': 'bold', 'color': 'red'})  # Adjust color as needed
        plt.ylabel('Frequency', fontdict={'fontsize': 10, 'fontweight': 'bold', 'color': 'red'})  # Adjust color as needed
        i += 1
    except:
        pass

plt.tight_layout()
plt.show()

#data grouping
groups2 = []
start = 0
for idx in (range(1, len(df))):
    if df.YEAR[idx-1] == df.YEAR[idx]:
        continue
    else:
        end = idx-1
        groups2.append((start, end))
        start = idx

groups2.append((start, len(df)-1))

df[start:end+1][cols].shape

remaining = ['HourlyDryBulbTemperature', 'HourlyRelativeHumidity', 'HourlySeaLevelPressure', 'HourlyStationPressure']

from sklearn.impute import SimpleImputer
for start, end in (groups2):
    imp1 = SimpleImputer(missing_values=np.nan, strategy='median')
    try:
        df.loc[start:end+1, cols] = imp1.fit_transform(df[remianing].loc[start:end+1, cols])
    except:
        pass

df.info()

blind_imputation = ['HourlyWindDirection', 'HourlyWindSpeed', 'HourlySeaLevelPressure', 'HourlyRelativeHumidity', 'HourlyDewPointTemperature', 'HourlyDryBulbTemperature']

imp1 = SimpleImputer(missing_values=np.nan, strategy='median')
df[blind_imputation] = imp1.fit_transform(df[blind_imputation])

df.info()

df.reset_index(drop=True, inplace=True)
df.head()

encode_cols = ["HourlyPresentWeatherType", "HourlySkyConditions"]

# Display feature information
for col in encode_cols:
    print(f"Feature: {col}\n")
    print(df[col].info())
    print("\n")

# Display feature value counts
for col in encode_cols:
    print(f"Feature: {col}")
    print(df[col].value_counts())
    print("\n")

# Encoding for HourlyPresentWeatherType
cat_vector_1 = df[encode_cols[0]].value_counts().index
encode_dict_1 = {cat: min(idx, 6) for idx, cat in enumerate(cat_vector_1)}
encode_dict_1['||s'] = 8
encode_dict_1[np.nan] = 8

df[encode_cols[0]] = df[encode_cols[0]].map(encode_dict_1)

# Encoding for HourlySkyConditions (assuming you want to keep the top 30 and categorize the rest as 'Other')
top_30_values = df[encode_cols[1]].value_counts().index[:30]
df[encode_cols[1]] = df[encode_cols[1]].apply(lambda x: x if x in top_30_values else 'Other')

# Display modified feature value counts
for col in encode_cols:
    print(f"Feature: {col}")
    print(df[col].value_counts())
    print("\n")

df.info()

df.STATION.value_counts()

df.describe()

df.head()

df.info()

df.drop(['HourlySkyConditions'], axis = 1, inplace = True)

df.info()

df.dropna(axis = 0, inplace = True)

df.info()

df.to_csv('Cleanyearlyimputation.csv', index=False)

